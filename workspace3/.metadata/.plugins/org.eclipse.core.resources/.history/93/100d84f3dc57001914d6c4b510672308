package inputGenerator;

import java.io.FileNotFoundException;
import java.util.Random;

import nz.ac.waikato.modeljunit.GraphListener;
import nz.ac.waikato.modeljunit.GreedyTester;
import nz.ac.waikato.modeljunit.StopOnFailureListener;
import nz.ac.waikato.modeljunit.coverage.ActionCoverage;
import nz.ac.waikato.modeljunit.coverage.StateCoverage;
import nz.ac.waikato.modeljunit.coverage.TransitionCoverage;
import nz.ac.waikato.modeljunit.coverage.TransitionPairCoverage;
import nz.ac.waikato.modeljunit.timing.Time;
import nz.ac.waikato.modeljunit.timing.TimedFsmModel;
import nz.ac.waikato.modeljunit.timing.TimedModel;

import com.liftmania.*;

import liftModel.ServiceList;

import java.util.ArrayList;

import javax.xml.ws.Action;

import org.junit.Test;

import inputGeneratorStates.ModelTesting_InputGeneratorStates;

public class ModelTesting_InputGenerator implements TimedFsmModel{ 

	private static final int PROBABILITY_TOTAL = 100;
	private static final int PROBABILITY_BUTTON_PRESS = 10;
    private ModelTesting_InputGeneratorStates modelState = ModelTesting_InputGeneratorStates.VALID;
    private	int numFloors = 0;
    private int numLifts = 0;
    private Random random = new Random();
    private LiftController sut;
    private Lift[] lifts;
    //private ArrayList<ServiceList> serviceList;
    private ArrayList<Integer> serviceList;
    private boolean check = false;
    
	@Time
    public int now;
	
    @Override
    public int getNextTimeIncrement(Random random) {
        return 1;
    }
	
    @Override
    public ModelTesting_InputGeneratorStates getState() {
        return modelState;
    }

    @Override
    public void reset(boolean reset) {
    	 modelState = ModelTesting_InputGeneratorStates.VALID;
        
         if (reset) {
             //assuming range of floors is between 0 and random max number
        	 numFloors = random.nextInt(10) + 2;
             numLifts = random.nextInt(10) + 2;
             sut = new LiftController(numFloors, numLifts, false);

             lifts = sut.getLifts();

          //   serviceList = new ArrayList<ServiceList>();
             now = 0;   
             check = false;    
         }
    }
	
    

    public boolean buttonPressGuard() {
 //       System.out.println("lift call guard");
        return  random.nextInt(PROBABILITY_TOTAL) < PROBABILITY_BUTTON_PRESS ;
    }

    //idle to servicing states through callLiftToFloor
    public @Action
    void buttonPress() {

        int counter = 0;

        modelState = ModelTesting_InputGeneratorStates.VALID;
        int randomFloorCall = random.nextInt(numFloors);
        
  
        if(serviceList.size()==0){
        	serviceList.add(randomFloorCall);
        }else{
        	if(!(serviceList.contains(randomFloorCall))){
        		serviceList.add(randomFloorCall);
        	}     	
        }

        sut.callLiftToFloor(randomFloorCall);

    }
    
    public boolean verifyBehaviourGuard() {

        return getState().equals(ModelTesting_InputGeneratorStates.VALID);
    }

    //idle to servicing states through callLiftToFloor
    public @Action
    void verifyBehaviour() {
        check = false;
        //to check if all of the call requests have been serviced
        modelState = ModelTesting_InputGeneratorStates.VALID;
        lifts = sut.getLifts();
        if (serviceList.size() == 0 && checkIfLiftsAreClosed())
            for (int i = 0; i < lifts.length; i++) {
   	
            	if ((lifts[i].isOpen()) &&(lifts[i].getBetweenFloors())) {
            		 check = true;
                     break; 
            		  
            	}
                //if all lifts are closed and stationary with items still required to be serviced - lift is invalid behaviour
                if (lifts[i].isOpen() && serviceList.size() == 0) {
                    check = true;
                    break;
                }

                if (!(lifts[i].getFloor() < numFloors && lifts[i].getFloor() >= 0)) {
                    check = true;
                    break;
                }
            }
    
        Assert.assertEquals("Expecting lift system to still be servicing requests ", false, check);
    }

    
    
    @Test
    public void LiftSystemModelRunner() throws FileNotFoundException {

        final TimedModel timedModel = new TimedModel(new ModelTesting_InputGenerator());
        //    timedModel.setTimeoutProbability(0.5);

        final GreedyTester tester = new GreedyTester(timedModel);
        tester.setRandom(new Random(100));
        tester.setResetProbability(0.001);
        final GraphListener graphListener = tester.buildGraph();
        //    graphListener.printGraphDot("/users/Owner/Desktop/output.dot");
        tester.addListener(new StopOnFailureListener());
        tester.addListener("verbose");
        tester.addCoverageMetric(new TransitionPairCoverage());
        tester.addCoverageMetric(new TransitionCoverage());
        tester.addCoverageMetric(new StateCoverage());
        tester.addCoverageMetric(new ActionCoverage());
        tester.generate(500);
        tester.printCoverage();
    }
    
    
    boolean checkIfLiftsAreClosed() {
        check = true;
        for (int i = 0; i < liftStates.size(); i++) {

            if (!liftStates.get(i).getLiftState().equals(LiftState.CLOSED)) {
                check = false;
                break;
            }

        }
        return check;
    }


}
